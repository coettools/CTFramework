/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = {
  /***/ "./src/CTFramework.ts":
    /*!****************************!*\
  !*** ./src/CTFramework.ts ***!
  \****************************/
    /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CTFramework: () => (/* binding */ CTFramework),\n/* harmony export */   createElement: () => (/* binding */ createElement)\n/* harmony export */ });\nfunction createElement(tag, props, ...children) {\r\n    props = props || {};\r\n        return {\r\n        tag,\r\n        props: Object.assign({}, props),\r\n        children: children.flat(),\r\n        key: (props === null || props === void 0 ? void 0 : props.key) || null,\r\n    };\r\n}\r\nclass CTFramework {\r\n    // Render a component into a DOM container.\r\n    static render(component, container) {\r\n        const vnode = component.render(); // Generate the initial virtual node from the component\'s render method.\r\n        vnode.component = component;\r\n        component.vnode = vnode;\r\n        const dom = CTFramework.createDom(vnode); // Create the actual DOM element from the virtual node.\r\n        container.appendChild(dom); // Attach it to the container.\r\n        CTFramework.onMount(vnode); // Trigger the component\'s mount lifecycle.\r\n    }\r\n    // Schedule updates to be processed in the next animation frame for better performance.\r\n    static scheduleUpdate(updateFn) {\r\n        CTFramework.pendingUpdates.push(updateFn);\r\n        if (CTFramework.pendingUpdates.length === 1) {\r\n            requestAnimationFrame(CTFramework.processUpdates);\r\n        }\r\n    }\r\n    // Process all pending updates from the queue.\r\n    static processUpdates() {\r\n        while (CTFramework.pendingUpdates.length) {\r\n            const updateFn = CTFramework.pendingUpdates.shift();\r\n            updateFn && updateFn();\r\n        }\r\n    }\r\n    // Re-render a component and update the DOM only if necessary.\r\n    static rerender(component) {\r\n        var _a, _b;\r\n        if (!component.vnode)\r\n            return;\r\n        const oldVNode = component.vnode;\r\n        if (!component.shouldComponentUpdate(component.props, component.state)) {\r\n            return; // Skip re-render if shouldComponentUpdate returns false.\r\n        }\r\n        const newVNode = component.render(); // Render the updated virtual node.\r\n        newVNode.component = component;\r\n        const updatedDom = CTFramework.updateDom(oldVNode, newVNode); // Update the DOM.\r\n        // Replace the DOM node if necessary.\r\n        if (typeof oldVNode !== "string" && updatedDom !== oldVNode.dom && oldVNode.dom) {\r\n            (_b = (_a = oldVNode.dom) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(updatedDom, oldVNode.dom);\r\n        }\r\n        component.vnode = newVNode; // Store the new virtual node in the component.\r\n        component.componentOnUpdate(component.props, component.state); // Trigger the update lifecycle.\r\n    }\r\n    // Create a DOM node from a virtual node.\r\n    static createDom(vnode) {\r\n        if (typeof vnode === "string" || typeof vnode === "number") {\r\n            return document.createTextNode(String(vnode)); // Convert numbers to text nodes as well.\r\n        }\r\n        if (typeof vnode.tag === "function") {\r\n            // Handle functional or class-based components.\r\n            const ComponentClass = vnode.tag;\r\n            const component = new ComponentClass(vnode.props);\r\n            const componentVNode = component.render();\r\n            componentVNode.component = component;\r\n            vnode.component = component;\r\n            component.vnode = componentVNode;\r\n            const dom = CTFramework.createDom(componentVNode);\r\n            vnode.dom = dom;\r\n            component.componentOnMount();\r\n            return dom;\r\n        }\r\n        const element = document.createElement(vnode.tag); // Create a DOM element for the tag.\r\n        vnode.dom = element;\r\n        // Event delegation: Attach a click-event attribute and store the event handler.\r\n        // Check if the vnode has an onClick prop before adding the event handler\r\n        if (vnode.props && vnode.props.onClick) {\r\n            const oldEventId = element.getAttribute("click-event");\r\n            if (oldEventId && CTFramework.eventHandlers[oldEventId]) {\r\n                                delete CTFramework.eventHandlers[oldEventId]; // Remove the old handler\r\n            }\r\n            // Only add the event listener and ID if the component has a click event\r\n            element.setAttribute("click-event", guid());\r\n            CTFramework.eventHandlers[element.getAttribute("click-event")] = vnode.props.onClick;\r\n        }\r\n        // Set properties and styles.\r\n        CTFramework.updateDomProperties(element, {}, vnode.props);\r\n        // Recursively create DOM for child nodes.\r\n        vnode.children.forEach((child) => {\r\n            const childDom = CTFramework.createDom(child);\r\n            element.appendChild(childDom);\r\n        });\r\n        return element;\r\n    }\r\n    // Update the DOM by comparing the old and new virtual nodes.\r\n    static updateDom(oldVNode, newVNode) {\r\n        // Handle text nodes\r\n        if (typeof oldVNode === "string" || typeof newVNode === "string") {\r\n            const newTextContent = (typeof newVNode === "string" ? newVNode : "") || "";\r\n            if (oldVNode !== newTextContent) {\r\n                return document.createTextNode(newTextContent);\r\n            }\r\n            return typeof oldVNode === "string" ? document.createTextNode(oldVNode) : oldVNode.dom;\r\n        }\r\n        // Static node check remains\r\n        if (oldVNode.isStatic) {\r\n            newVNode.dom = oldVNode.dom;\r\n            newVNode.component = oldVNode.component;\r\n            return newVNode.dom;\r\n        }\r\n        // Replace node if tag is different\r\n        if (oldVNode.tag !== newVNode.tag) {\r\n            const newDom = CTFramework.createDom(newVNode);\r\n            if (oldVNode.dom && oldVNode.dom.parentNode) {\r\n                oldVNode.dom.parentNode.replaceChild(newDom, oldVNode.dom);\r\n            }\r\n            return newDom;\r\n        }\r\n        const dom = oldVNode.dom;\r\n        newVNode.dom = dom;\r\n        // **Ensure text content is updated**:\r\n        // If we\'re dealing with text inside an element (like <h1>)\r\n        if (newVNode.children.length === 1 && typeof newVNode.children[0] === "string") {\r\n            if (dom.textContent !== newVNode.children[0]) {\r\n                dom.textContent = newVNode.children[0]; // Update text directly\r\n            }\r\n        }\r\n        // Update properties even if children haven\'t changed\r\n        CTFramework.updateDomProperties(dom, oldVNode.props, newVNode.props);\r\n        // Handle children updates (only if they exist)\r\n        const oldChildren = oldVNode.children || [];\r\n        const newChildren = newVNode.children || [];\r\n        if (oldChildren.length === 0 && newChildren.length === 0) {\r\n            return CTFramework.createDom(newVNode);\r\n        }\r\n        const oldChildrenMap = new Map();\r\n        // Map old children by keys if any\r\n        oldChildren.forEach((child) => {\r\n            if (child && typeof child !== "string" && child.key) {\r\n                oldChildrenMap.set(child.key, child); // **Track children by key**\r\n            }\r\n        });\r\n        // **Iterate through new children**\r\n        newChildren.forEach((newChild, i) => {\r\n            if (typeof newChild === "string") {\r\n                const newTextContent = newChild || "";\r\n                const oldChild = oldChildren[i];\r\n                if (typeof oldChild === "string" && oldChild !== newTextContent) {\r\n                    // **Update text content if needed**\r\n                    dom.childNodes[i].textContent = newTextContent;\r\n                }\r\n                else if (dom.childNodes[i]) {\r\n                    dom.replaceChild(document.createTextNode(newTextContent), dom.childNodes[i]);\r\n                }\r\n                else {\r\n                    dom.appendChild(document.createTextNode(newTextContent));\r\n                }\r\n            }\r\n            else {\r\n                const key = newChild.key;\r\n                const oldChild = key ? oldChildrenMap.get(key) : oldChildren[i]; // **Look for matching old child by key or index**\r\n                if (oldChild) {\r\n                    // **Update the DOM for the matching child**\r\n                    const updatedChildDom = CTFramework.updateDom(oldChild, newChild);\r\n                    if (dom.childNodes[i] !== updatedChildDom) {\r\n                        dom.replaceChild(updatedChildDom, dom.childNodes[i]);\r\n                    }\r\n                    if (key)\r\n                        oldChildrenMap.delete(key); // **Remove key from map once updated**\r\n                }\r\n                else {\r\n                    // **If no matching old child, create a new DOM node**\r\n                    const newChildDom = CTFramework.createDom(newChild);\r\n                    dom.appendChild(newChildDom);\r\n                }\r\n            }\r\n        });\r\n        // **Remove old children that are no longer present**\r\n        oldChildrenMap.forEach((oldChild) => {\r\n            if (oldChild.dom && dom.contains(oldChild.dom)) {\r\n                dom.removeChild(oldChild.dom); // **Remove old DOM elements that are no longer in newVNode**\r\n            }\r\n        });\r\n        return dom;\r\n    }\r\n    // Update the properties and styles of a DOM element.\r\n    static updateDomProperties(dom, oldProps = {}, newProps = {}) {\r\n        var _a;\r\n        const changes = CTFramework.getPropChanges(oldProps, newProps);\r\n        // Check if click-event exists on the DOM element, otherwise create one\r\n        let eventId = (_a = dom.getAttribute("click-event")) !== null && _a !== void 0 ? _a : "";\r\n        changes.forEach(({ name, value }) => {\r\n            if (name === "style") {\r\n                CTFramework.updateStyle(dom, oldProps.style, newProps.style);\r\n            }\r\n            else if (name.startsWith("on")) {\r\n                const eventType = name.toLowerCase().substring(2);\r\n                // Remove the old event listener from CTFramework.eventHandlers using click-event\r\n                if (CTFramework.eventHandlers[eventId]) {\r\n                                        delete CTFramework.eventHandlers[eventId]; // Remove from event handlers map\r\n                }\r\n                // Add the new event listener in CTFramework.eventHandlers using click-event\r\n                if (value && typeof value === "function") {\r\n                                        CTFramework.eventHandlers[eventId] = value; // Update the event handler in the map\r\n                }\r\n            }\r\n            else if (name === "textContent") {\r\n                dom.textContent = value;\r\n            }\r\n            else if (name in dom) {\r\n                dom[name] = value;\r\n            }\r\n            else {\r\n                dom.setAttribute(name, value);\r\n            }\r\n        });\r\n    }\r\n    // Get the differences between the old and new props for efficient updates.\r\n    static getPropChanges(oldProps, newProps) {\r\n        const changes = [];\r\n        for (const name in newProps) {\r\n            if (newProps[name] !== oldProps[name]) {\r\n                changes.push({ name, value: newProps[name] });\r\n            }\r\n        }\r\n        return changes;\r\n    }\r\n    // Add the missing updateStyle function.\r\n    static updateStyle(dom, oldStyle = {}, newStyle = {}) {\r\n        // If styles are provided as a string, update the style attribute.\r\n        if (typeof oldStyle === "string" || typeof newStyle === "string") {\r\n            dom.setAttribute("style", newStyle || "");\r\n        }\r\n        else {\r\n            // Remove old styles not present in the new styles.\r\n            Object.keys(oldStyle).forEach((key) => {\r\n                if (!(key in newStyle)) {\r\n                    dom.style[key] = "";\r\n                }\r\n            });\r\n            // Apply new styles.\r\n            Object.keys(newStyle).forEach((key) => {\r\n                if (oldStyle[key] !== newStyle[key]) {\r\n                    dom.style[key] = newStyle[key];\r\n                }\r\n            });\r\n        }\r\n    }\r\n    // Helper method to handle the component mount lifecycle.\r\n    static onMount(vnode) {\r\n        if (typeof vnode === "string")\r\n            return;\r\n        if (vnode.component) {\r\n            vnode.component.componentOnMount(); // Trigger component mount lifecycle.\r\n        }\r\n        vnode.children.forEach((child) => CTFramework.onMount(child));\r\n    }\r\n    // Helper method to handle the component unmount lifecycle.\r\n    static onUnmount(vnode) {\r\n        if (typeof vnode === "string")\r\n            return;\r\n        if (vnode.component) {\r\n            vnode.component.componentOnUnmount(); // Trigger component unmount lifecycle.\r\n        }\r\n        vnode.children.forEach((child) => CTFramework.onUnmount(child));\r\n    }\r\n}\r\nCTFramework.eventHandlers = {}; // Store event handlers by their unique event ID.\r\nCTFramework.pendingUpdates = []; // Queue for pending updates to be processed.\r\nfunction guid() {\r\n    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16) | 0;\r\n        const v = c === "x" ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n}\r\n// Event delegation: A single event listener handles all click events.\r\ndocument.addEventListener("click", (event) => {\r\n    let target = event.target;\r\n    while (target && !target.hasAttribute("click-event")) {\r\n        target = target.parentElement;\r\n    }\r\n    if (target) {\r\n        const handler = CTFramework.eventHandlers[target.getAttribute("click-event")];\r\n        handler && handler(event);\r\n    }\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3hCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELHNFQUFzRTtBQUN0RSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7SUFDM0MsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQXFCLENBQUM7SUFDekMsT0FBTyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ3BELE1BQU0sR0FBRyxNQUFNLENBQUMsYUFBYyxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxNQUFNLEVBQUU7UUFDVixNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFXLENBQUMsQ0FBQztRQUN4RixPQUFPLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzNCO0FBQ0gsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdGZyYW1ld29yay8uL3NyYy9DVEZyYW1ld29yay50cz8yM2JjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuL0NvbXBvbmVudFwiO1xyXG5pbXBvcnQgeyBWTm9kZSB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWc6IHN0cmluZyB8ICgocHJvcHM6IGFueSkgPT4gVk5vZGUpIHwgKG5ldyAocHJvcHM6IGFueSkgPT4gQ29tcG9uZW50PGFueSwgYW55PiksIHByb3BzOiBhbnksIC4uLmNoaWxkcmVuOiAoVk5vZGUgfCBzdHJpbmcpW10pOiBWTm9kZSB7XHJcbiAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIGVsZW1lbnQ6XCIsIHRhZywgcHJvcHMsIGNoaWxkcmVuKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHRhZyxcclxuICAgIHByb3BzOiB7IC4uLnByb3BzIH0sXHJcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4uZmxhdCgpLFxyXG4gICAga2V5OiBwcm9wcz8ua2V5IHx8IG51bGwsXHJcbiAgfTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENURnJhbWV3b3JrIHtcclxuICBzdGF0aWMgZXZlbnRIYW5kbGVyczogeyBba2V5OiBzdHJpbmddOiBGdW5jdGlvbiB9ID0ge307IC8vIFN0b3JlIGV2ZW50IGhhbmRsZXJzIGJ5IHRoZWlyIHVuaXF1ZSBldmVudCBJRC5cclxuICBzdGF0aWMgcGVuZGluZ1VwZGF0ZXM6IEZ1bmN0aW9uW10gPSBbXTsgLy8gUXVldWUgZm9yIHBlbmRpbmcgdXBkYXRlcyB0byBiZSBwcm9jZXNzZWQuXHJcblxyXG4gIC8vIFJlbmRlciBhIGNvbXBvbmVudCBpbnRvIGEgRE9NIGNvbnRhaW5lci5cclxuICBzdGF0aWMgcmVuZGVyPFAgPSB7fSwgUyA9IHt9Pihjb21wb25lbnQ6IENvbXBvbmVudDxQLCBTPiwgY29udGFpbmVyOiBIVE1MRWxlbWVudCkge1xyXG4gICAgY29uc3Qgdm5vZGUgPSBjb21wb25lbnQucmVuZGVyKCk7IC8vIEdlbmVyYXRlIHRoZSBpbml0aWFsIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kLlxyXG4gICAgdm5vZGUuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgY29tcG9uZW50LnZub2RlID0gdm5vZGU7XHJcbiAgICBjb25zdCBkb20gPSBDVEZyYW1ld29yay5jcmVhdGVEb20odm5vZGUpOyAvLyBDcmVhdGUgdGhlIGFjdHVhbCBET00gZWxlbWVudCBmcm9tIHRoZSB2aXJ0dWFsIG5vZGUuXHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9tKTsgLy8gQXR0YWNoIGl0IHRvIHRoZSBjb250YWluZXIuXHJcbiAgICBDVEZyYW1ld29yay5vbk1vdW50KHZub2RlKTsgLy8gVHJpZ2dlciB0aGUgY29tcG9uZW50J3MgbW91bnQgbGlmZWN5Y2xlLlxyXG4gIH1cclxuXHJcbiAgLy8gU2NoZWR1bGUgdXBkYXRlcyB0byBiZSBwcm9jZXNzZWQgaW4gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbiAgc3RhdGljIHNjaGVkdWxlVXBkYXRlKHVwZGF0ZUZuOiBGdW5jdGlvbikge1xyXG4gICAgQ1RGcmFtZXdvcmsucGVuZGluZ1VwZGF0ZXMucHVzaCh1cGRhdGVGbik7XHJcbiAgICBpZiAoQ1RGcmFtZXdvcmsucGVuZGluZ1VwZGF0ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShDVEZyYW1ld29yay5wcm9jZXNzVXBkYXRlcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQcm9jZXNzIGFsbCBwZW5kaW5nIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUuXHJcbiAgc3RhdGljIHByb2Nlc3NVcGRhdGVzKCkge1xyXG4gICAgd2hpbGUgKENURnJhbWV3b3JrLnBlbmRpbmdVcGRhdGVzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCB1cGRhdGVGbiA9IENURnJhbWV3b3JrLnBlbmRpbmdVcGRhdGVzLnNoaWZ0KCk7XHJcbiAgICAgIHVwZGF0ZUZuICYmIHVwZGF0ZUZuKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZS1yZW5kZXIgYSBjb21wb25lbnQgYW5kIHVwZGF0ZSB0aGUgRE9NIG9ubHkgaWYgbmVjZXNzYXJ5LlxyXG4gIHN0YXRpYyByZXJlbmRlcjxQID0ge30sIFMgPSB7fT4oY29tcG9uZW50OiBDb21wb25lbnQ8UCwgUz4pIHtcclxuICAgIGlmICghY29tcG9uZW50LnZub2RlKSByZXR1cm47XHJcblxyXG4gICAgY29uc3Qgb2xkVk5vZGUgPSBjb21wb25lbnQudm5vZGU7XHJcblxyXG4gICAgaWYgKCFjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlKGNvbXBvbmVudC5wcm9wcywgY29tcG9uZW50LnN0YXRlKSkge1xyXG4gICAgICByZXR1cm47IC8vIFNraXAgcmUtcmVuZGVyIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5ld1ZOb2RlID0gY29tcG9uZW50LnJlbmRlcigpOyAvLyBSZW5kZXIgdGhlIHVwZGF0ZWQgdmlydHVhbCBub2RlLlxyXG4gICAgbmV3Vk5vZGUuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZWREb20gPSBDVEZyYW1ld29yay51cGRhdGVEb20ob2xkVk5vZGUsIG5ld1ZOb2RlKTsgLy8gVXBkYXRlIHRoZSBET00uXHJcblxyXG4gICAgLy8gUmVwbGFjZSB0aGUgRE9NIG5vZGUgaWYgbmVjZXNzYXJ5LlxyXG4gICAgaWYgKHR5cGVvZiBvbGRWTm9kZSAhPT0gXCJzdHJpbmdcIiAmJiB1cGRhdGVkRG9tICE9PSBvbGRWTm9kZS5kb20gJiYgb2xkVk5vZGUuZG9tKSB7XHJcbiAgICAgIG9sZFZOb2RlLmRvbT8ucGFyZW50Tm9kZT8ucmVwbGFjZUNoaWxkKHVwZGF0ZWREb20sIG9sZFZOb2RlLmRvbSBhcyBOb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnQudm5vZGUgPSBuZXdWTm9kZTsgLy8gU3RvcmUgdGhlIG5ldyB2aXJ0dWFsIG5vZGUgaW4gdGhlIGNvbXBvbmVudC5cclxuICAgIGNvbXBvbmVudC5jb21wb25lbnRPblVwZGF0ZShjb21wb25lbnQucHJvcHMsIGNvbXBvbmVudC5zdGF0ZSk7IC8vIFRyaWdnZXIgdGhlIHVwZGF0ZSBsaWZlY3ljbGUuXHJcbiAgfVxyXG5cclxuICAvLyBDcmVhdGUgYSBET00gbm9kZSBmcm9tIGEgdmlydHVhbCBub2RlLlxyXG4gIHN0YXRpYyBjcmVhdGVEb20odm5vZGU6IFZOb2RlIHwgc3RyaW5nIHwgbnVtYmVyKTogSFRNTEVsZW1lbnQgfCBUZXh0IHtcclxuICAgIGlmICh0eXBlb2Ygdm5vZGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZub2RlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUpKTsgLy8gQ29udmVydCBudW1iZXJzIHRvIHRleHQgbm9kZXMgYXMgd2VsbC5cclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHZub2RlLnRhZyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgIC8vIEhhbmRsZSBmdW5jdGlvbmFsIG9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMuXHJcbiAgICAgIGNvbnN0IENvbXBvbmVudENsYXNzID0gdm5vZGUudGFnIGFzIG5ldyAocHJvcHM6IGFueSkgPT4gQ29tcG9uZW50PGFueSwgYW55PjtcclxuICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHZub2RlLnByb3BzKTtcclxuICAgICAgY29uc3QgY29tcG9uZW50Vk5vZGUgPSBjb21wb25lbnQucmVuZGVyKCk7XHJcbiAgICAgIGNvbXBvbmVudFZOb2RlLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgdm5vZGUuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICBjb21wb25lbnQudm5vZGUgPSBjb21wb25lbnRWTm9kZTtcclxuICAgICAgY29uc3QgZG9tID0gQ1RGcmFtZXdvcmsuY3JlYXRlRG9tKGNvbXBvbmVudFZOb2RlKTtcclxuICAgICAgdm5vZGUuZG9tID0gZG9tO1xyXG4gICAgICBjb21wb25lbnQuY29tcG9uZW50T25Nb3VudCgpO1xyXG4gICAgICByZXR1cm4gZG9tO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHZub2RlLnRhZyBhcyBzdHJpbmcpOyAvLyBDcmVhdGUgYSBET00gZWxlbWVudCBmb3IgdGhlIHRhZy5cclxuICAgIHZub2RlLmRvbSA9IGVsZW1lbnQ7XHJcblxyXG4gICAgLy8gRXZlbnQgZGVsZWdhdGlvbjogQXR0YWNoIGEgY2xpY2stZXZlbnQgYXR0cmlidXRlIGFuZCBzdG9yZSB0aGUgZXZlbnQgaGFuZGxlci5cclxuICAgIC8vIENoZWNrIGlmIHRoZSB2bm9kZSBoYXMgYW4gb25DbGljayBwcm9wIGJlZm9yZSBhZGRpbmcgdGhlIGV2ZW50IGhhbmRsZXJcclxuICAgIGlmICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vbkNsaWNrKSB7XHJcbiAgICAgIGNvbnN0IG9sZEV2ZW50SWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNsaWNrLWV2ZW50XCIpO1xyXG4gICAgICBpZiAob2xkRXZlbnRJZCAmJiBDVEZyYW1ld29yay5ldmVudEhhbmRsZXJzW29sZEV2ZW50SWRdKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJkZWxldGUgb2xkIGV2ZW50XCIpO1xyXG4gICAgICAgIGRlbGV0ZSBDVEZyYW1ld29yay5ldmVudEhhbmRsZXJzW29sZEV2ZW50SWRdOyAvLyBSZW1vdmUgdGhlIG9sZCBoYW5kbGVyXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9ubHkgYWRkIHRoZSBldmVudCBsaXN0ZW5lciBhbmQgSUQgaWYgdGhlIGNvbXBvbmVudCBoYXMgYSBjbGljayBldmVudFxyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNsaWNrLWV2ZW50XCIsIGd1aWQoKSk7XHJcbiAgICAgIENURnJhbWV3b3JrLmV2ZW50SGFuZGxlcnNbZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjbGljay1ldmVudFwiKSBhcyBzdHJpbmddID0gdm5vZGUucHJvcHMub25DbGljaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgcHJvcGVydGllcyBhbmQgc3R5bGVzLlxyXG4gICAgQ1RGcmFtZXdvcmsudXBkYXRlRG9tUHJvcGVydGllcyhlbGVtZW50LCB7fSwgdm5vZGUucHJvcHMpO1xyXG5cclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNyZWF0ZSBET00gZm9yIGNoaWxkIG5vZGVzLlxyXG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcclxuICAgICAgY29uc3QgY2hpbGREb20gPSBDVEZyYW1ld29yay5jcmVhdGVEb20oY2hpbGQpO1xyXG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkRG9tKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIHRoZSBET00gYnkgY29tcGFyaW5nIHRoZSBvbGQgYW5kIG5ldyB2aXJ0dWFsIG5vZGVzLlxyXG4gIHN0YXRpYyB1cGRhdGVEb20ob2xkVk5vZGU6IFZOb2RlIHwgc3RyaW5nLCBuZXdWTm9kZTogVk5vZGUgfCBzdHJpbmcpOiBIVE1MRWxlbWVudCB8IFRleHQge1xyXG4gICAgLy8gSGFuZGxlIHRleHQgbm9kZXNcclxuICAgIGlmICh0eXBlb2Ygb2xkVk5vZGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG5ld1ZOb2RlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGNvbnN0IG5ld1RleHRDb250ZW50ID0gKHR5cGVvZiBuZXdWTm9kZSA9PT0gXCJzdHJpbmdcIiA/IG5ld1ZOb2RlIDogXCJcIikgfHwgXCJcIjtcclxuICAgICAgaWYgKG9sZFZOb2RlICE9PSBuZXdUZXh0Q29udGVudCkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdUZXh0Q29udGVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR5cGVvZiBvbGRWTm9kZSA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9sZFZOb2RlKSA6ICgob2xkVk5vZGUgYXMgVk5vZGUpLmRvbSBhcyBUZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWMgbm9kZSBjaGVjayByZW1haW5zXHJcbiAgICBpZiAob2xkVk5vZGUuaXNTdGF0aWMpIHtcclxuICAgICAgbmV3Vk5vZGUuZG9tID0gb2xkVk5vZGUuZG9tO1xyXG4gICAgICBuZXdWTm9kZS5jb21wb25lbnQgPSBvbGRWTm9kZS5jb21wb25lbnQ7XHJcbiAgICAgIHJldHVybiBuZXdWTm9kZS5kb20gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwbGFjZSBub2RlIGlmIHRhZyBpcyBkaWZmZXJlbnRcclxuICAgIGlmIChvbGRWTm9kZS50YWcgIT09IG5ld1ZOb2RlLnRhZykge1xyXG4gICAgICBjb25zdCBuZXdEb20gPSBDVEZyYW1ld29yay5jcmVhdGVEb20obmV3Vk5vZGUpO1xyXG4gICAgICBpZiAob2xkVk5vZGUuZG9tICYmIG9sZFZOb2RlLmRvbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgb2xkVk5vZGUuZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0RvbSwgb2xkVk5vZGUuZG9tKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3RG9tO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRvbSA9IG9sZFZOb2RlLmRvbSBhcyBIVE1MRWxlbWVudDtcclxuICAgIG5ld1ZOb2RlLmRvbSA9IGRvbTtcclxuXHJcbiAgICAvLyAqKkVuc3VyZSB0ZXh0IGNvbnRlbnQgaXMgdXBkYXRlZCoqOlxyXG4gICAgLy8gSWYgd2UncmUgZGVhbGluZyB3aXRoIHRleHQgaW5zaWRlIGFuIGVsZW1lbnQgKGxpa2UgPGgxPilcclxuICAgIGlmIChuZXdWTm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5ld1ZOb2RlLmNoaWxkcmVuWzBdID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIGlmIChkb20udGV4dENvbnRlbnQgIT09IG5ld1ZOb2RlLmNoaWxkcmVuWzBdKSB7XHJcbiAgICAgICAgZG9tLnRleHRDb250ZW50ID0gbmV3Vk5vZGUuY2hpbGRyZW5bMF0gYXMgc3RyaW5nOyAvLyBVcGRhdGUgdGV4dCBkaXJlY3RseVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHByb3BlcnRpZXMgZXZlbiBpZiBjaGlsZHJlbiBoYXZlbid0IGNoYW5nZWRcclxuICAgIENURnJhbWV3b3JrLnVwZGF0ZURvbVByb3BlcnRpZXMoZG9tLCBvbGRWTm9kZS5wcm9wcywgbmV3Vk5vZGUucHJvcHMpO1xyXG5cclxuICAgIC8vIEhhbmRsZSBjaGlsZHJlbiB1cGRhdGVzIChvbmx5IGlmIHRoZXkgZXhpc3QpXHJcbiAgICBjb25zdCBvbGRDaGlsZHJlbiA9IG9sZFZOb2RlLmNoaWxkcmVuIHx8IFtdO1xyXG4gICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZS5jaGlsZHJlbiB8fCBbXTtcclxuXHJcbiAgICBpZiAob2xkQ2hpbGRyZW4ubGVuZ3RoID09PSAwICYmIG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gQ1RGcmFtZXdvcmsuY3JlYXRlRG9tKG5ld1ZOb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvbGRDaGlsZHJlbk1hcCA9IG5ldyBNYXA8c3RyaW5nLCBWTm9kZT4oKTtcclxuXHJcbiAgICAvLyBNYXAgb2xkIGNoaWxkcmVuIGJ5IGtleXMgaWYgYW55XHJcbiAgICBvbGRDaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkICE9PSBcInN0cmluZ1wiICYmIGNoaWxkLmtleSkge1xyXG4gICAgICAgIG9sZENoaWxkcmVuTWFwLnNldChjaGlsZC5rZXkgYXMgc3RyaW5nLCBjaGlsZCk7IC8vICoqVHJhY2sgY2hpbGRyZW4gYnkga2V5KipcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gKipJdGVyYXRlIHRocm91Z2ggbmV3IGNoaWxkcmVuKipcclxuICAgIG5ld0NoaWxkcmVuLmZvckVhY2goKG5ld0NoaWxkLCBpKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjb25zdCBuZXdUZXh0Q29udGVudCA9IG5ld0NoaWxkIHx8IFwiXCI7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBvbGRDaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAodHlwZW9mIG9sZENoaWxkID09PSBcInN0cmluZ1wiICYmIG9sZENoaWxkICE9PSBuZXdUZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgLy8gKipVcGRhdGUgdGV4dCBjb250ZW50IGlmIG5lZWRlZCoqXHJcbiAgICAgICAgICBkb20uY2hpbGROb2Rlc1tpXS50ZXh0Q29udGVudCA9IG5ld1RleHRDb250ZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZG9tLmNoaWxkTm9kZXNbaV0pIHtcclxuICAgICAgICAgIGRvbS5yZXBsYWNlQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3VGV4dENvbnRlbnQpLCBkb20uY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdUZXh0Q29udGVudCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBrZXkgPSAobmV3Q2hpbGQgYXMgVk5vZGUpLmtleSBhcyBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBrZXkgPyBvbGRDaGlsZHJlbk1hcC5nZXQoa2V5KSA6IG9sZENoaWxkcmVuW2ldOyAvLyAqKkxvb2sgZm9yIG1hdGNoaW5nIG9sZCBjaGlsZCBieSBrZXkgb3IgaW5kZXgqKlxyXG5cclxuICAgICAgICBpZiAob2xkQ2hpbGQpIHtcclxuICAgICAgICAgIC8vICoqVXBkYXRlIHRoZSBET00gZm9yIHRoZSBtYXRjaGluZyBjaGlsZCoqXHJcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQ2hpbGREb20gPSBDVEZyYW1ld29yay51cGRhdGVEb20ob2xkQ2hpbGQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgIGlmIChkb20uY2hpbGROb2Rlc1tpXSAhPT0gdXBkYXRlZENoaWxkRG9tKSB7XHJcbiAgICAgICAgICAgIGRvbS5yZXBsYWNlQ2hpbGQodXBkYXRlZENoaWxkRG9tLCBkb20uY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoa2V5KSBvbGRDaGlsZHJlbk1hcC5kZWxldGUoa2V5KTsgLy8gKipSZW1vdmUga2V5IGZyb20gbWFwIG9uY2UgdXBkYXRlZCoqXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vICoqSWYgbm8gbWF0Y2hpbmcgb2xkIGNoaWxkLCBjcmVhdGUgYSBuZXcgRE9NIG5vZGUqKlxyXG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGREb20gPSBDVEZyYW1ld29yay5jcmVhdGVEb20obmV3Q2hpbGQpO1xyXG4gICAgICAgICAgZG9tLmFwcGVuZENoaWxkKG5ld0NoaWxkRG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vICoqUmVtb3ZlIG9sZCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCoqXHJcbiAgICBvbGRDaGlsZHJlbk1hcC5mb3JFYWNoKChvbGRDaGlsZCkgPT4ge1xyXG4gICAgICBpZiAob2xkQ2hpbGQuZG9tICYmIGRvbS5jb250YWlucyhvbGRDaGlsZC5kb20pKSB7XHJcbiAgICAgICAgZG9tLnJlbW92ZUNoaWxkKG9sZENoaWxkLmRvbSk7IC8vICoqUmVtb3ZlIG9sZCBET00gZWxlbWVudHMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIG5ld1ZOb2RlKipcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGRvbTtcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSB0aGUgcHJvcGVydGllcyBhbmQgc3R5bGVzIG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAgc3RhdGljIHVwZGF0ZURvbVByb3BlcnRpZXMoZG9tOiBIVE1MRWxlbWVudCwgb2xkUHJvcHM6IGFueSA9IHt9LCBuZXdQcm9wczogYW55ID0ge30pIHtcclxuICAgIGNvbnN0IGNoYW5nZXMgPSBDVEZyYW1ld29yay5nZXRQcm9wQ2hhbmdlcyhvbGRQcm9wcywgbmV3UHJvcHMpO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIGNsaWNrLWV2ZW50IGV4aXN0cyBvbiB0aGUgRE9NIGVsZW1lbnQsIG90aGVyd2lzZSBjcmVhdGUgb25lXHJcbiAgICBsZXQgZXZlbnRJZCA9IGRvbS5nZXRBdHRyaWJ1dGUoXCJjbGljay1ldmVudFwiKSA/PyBcIlwiO1xyXG5cclxuICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuYW1lLCB2YWx1ZSB9OiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IGFueSB9KSA9PiB7XHJcbiAgICAgIGlmIChuYW1lID09PSBcInN0eWxlXCIpIHtcclxuICAgICAgICBDVEZyYW1ld29yay51cGRhdGVTdHlsZShkb20sIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKFwib25cIikpIHtcclxuICAgICAgICBjb25zdCBldmVudFR5cGUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBldmVudCBsaXN0ZW5lciBmcm9tIENURnJhbWV3b3JrLmV2ZW50SGFuZGxlcnMgdXNpbmcgY2xpY2stZXZlbnRcclxuICAgICAgICBpZiAoQ1RGcmFtZXdvcmsuZXZlbnRIYW5kbGVyc1tldmVudElkXSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYFJlbW92aW5nIG9sZCBldmVudCBsaXN0ZW5lciBmb3IgJHtldmVudFR5cGV9YCwgZXZlbnRJZCwgQ1RGcmFtZXdvcmsuZXZlbnRIYW5kbGVyc1tldmVudElkXSk7XHJcbiAgICAgICAgICBkZWxldGUgQ1RGcmFtZXdvcmsuZXZlbnRIYW5kbGVyc1tldmVudElkXTsgLy8gUmVtb3ZlIGZyb20gZXZlbnQgaGFuZGxlcnMgbWFwXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG5ldyBldmVudCBsaXN0ZW5lciBpbiBDVEZyYW1ld29yay5ldmVudEhhbmRsZXJzIHVzaW5nIGNsaWNrLWV2ZW50XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIG5ldyBldmVudCBsaXN0ZW5lciBmb3IgJHtldmVudFR5cGV9YCwgZXZlbnRJZCwgdmFsdWUpO1xyXG4gICAgICAgICAgQ1RGcmFtZXdvcmsuZXZlbnRIYW5kbGVyc1tldmVudElkXSA9IHZhbHVlOyAvLyBVcGRhdGUgdGhlIGV2ZW50IGhhbmRsZXIgaW4gdGhlIG1hcFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBcInRleHRDb250ZW50XCIpIHtcclxuICAgICAgICBkb20udGV4dENvbnRlbnQgPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGRvbSkge1xyXG4gICAgICAgIChkb20gYXMgYW55KVtuYW1lXSA9IHZhbHVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgcHJvcHMgZm9yIGVmZmljaWVudCB1cGRhdGVzLlxyXG4gIHN0YXRpYyBnZXRQcm9wQ2hhbmdlcyhvbGRQcm9wczogYW55LCBuZXdQcm9wczogYW55KTogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBhbnkgfVtdIHtcclxuICAgIGNvbnN0IGNoYW5nZXM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogYW55IH1bXSA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5ld1Byb3BzKSB7XHJcbiAgICAgIGlmIChuZXdQcm9wc1tuYW1lXSAhPT0gb2xkUHJvcHNbbmFtZV0pIHtcclxuICAgICAgICBjaGFuZ2VzLnB1c2goeyBuYW1lLCB2YWx1ZTogbmV3UHJvcHNbbmFtZV0gfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGFuZ2VzO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHRoZSBtaXNzaW5nIHVwZGF0ZVN0eWxlIGZ1bmN0aW9uLlxyXG4gIHN0YXRpYyB1cGRhdGVTdHlsZShkb206IEhUTUxFbGVtZW50LCBvbGRTdHlsZTogYW55ID0ge30sIG5ld1N0eWxlOiBhbnkgPSB7fSkge1xyXG4gICAgLy8gSWYgc3R5bGVzIGFyZSBwcm92aWRlZCBhcyBhIHN0cmluZywgdXBkYXRlIHRoZSBzdHlsZSBhdHRyaWJ1dGUuXHJcbiAgICBpZiAodHlwZW9mIG9sZFN0eWxlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBuZXdTdHlsZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBkb20uc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgbmV3U3R5bGUgfHwgXCJcIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBSZW1vdmUgb2xkIHN0eWxlcyBub3QgcHJlc2VudCBpbiB0aGUgbmV3IHN0eWxlcy5cclxuICAgICAgT2JqZWN0LmtleXMob2xkU3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBuZXdTdHlsZSkpIHtcclxuICAgICAgICAgIGRvbS5zdHlsZVtrZXkgYXMgYW55XSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIEFwcGx5IG5ldyBzdHlsZXMuXHJcbiAgICAgIE9iamVjdC5rZXlzKG5ld1N0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICBpZiAob2xkU3R5bGVba2V5XSAhPT0gbmV3U3R5bGVba2V5XSkge1xyXG4gICAgICAgICAgZG9tLnN0eWxlW2tleSBhcyBhbnldID0gbmV3U3R5bGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIG1ldGhvZCB0byBoYW5kbGUgdGhlIGNvbXBvbmVudCBtb3VudCBsaWZlY3ljbGUuXHJcbiAgc3RhdGljIG9uTW91bnQodm5vZGU6IFZOb2RlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZub2RlID09PSBcInN0cmluZ1wiKSByZXR1cm47XHJcblxyXG4gICAgaWYgKHZub2RlLmNvbXBvbmVudCkge1xyXG4gICAgICB2bm9kZS5jb21wb25lbnQuY29tcG9uZW50T25Nb3VudCgpOyAvLyBUcmlnZ2VyIGNvbXBvbmVudCBtb3VudCBsaWZlY3ljbGUuXHJcbiAgICB9XHJcblxyXG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IENURnJhbWV3b3JrLm9uTW91bnQoY2hpbGQgYXMgVk5vZGUpKTtcclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBtZXRob2QgdG8gaGFuZGxlIHRoZSBjb21wb25lbnQgdW5tb3VudCBsaWZlY3ljbGUuXHJcbiAgc3RhdGljIG9uVW5tb3VudCh2bm9kZTogVk5vZGUpIHtcclxuICAgIGlmICh0eXBlb2Ygdm5vZGUgPT09IFwic3RyaW5nXCIpIHJldHVybjtcclxuXHJcbiAgICBpZiAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgIHZub2RlLmNvbXBvbmVudC5jb21wb25lbnRPblVubW91bnQoKTsgLy8gVHJpZ2dlciBjb21wb25lbnQgdW5tb3VudCBsaWZlY3ljbGUuXHJcbiAgICB9XHJcblxyXG4gICAgdm5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IENURnJhbWV3b3JrLm9uVW5tb3VudChjaGlsZCBhcyBWTm9kZSkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ3VpZCgpOiBzdHJpbmcge1xyXG4gIHJldHVybiBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcclxuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDA7XHJcbiAgICBjb25zdCB2ID0gYyA9PT0gXCJ4XCIgPyByIDogKHIgJiAweDMpIHwgMHg4O1xyXG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBFdmVudCBkZWxlZ2F0aW9uOiBBIHNpbmdsZSBldmVudCBsaXN0ZW5lciBoYW5kbGVzIGFsbCBjbGljayBldmVudHMuXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHtcclxuICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gIHdoaWxlICh0YXJnZXQgJiYgIXRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjbGljay1ldmVudFwiKSkge1xyXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQhO1xyXG4gIH1cclxuICBpZiAodGFyZ2V0KSB7XHJcbiAgICBjb25zdCBoYW5kbGVyID0gQ1RGcmFtZXdvcmsuZXZlbnRIYW5kbGVyc1t0YXJnZXQuZ2V0QXR0cmlidXRlKFwiY2xpY2stZXZlbnRcIikgYXMgc3RyaW5nXTtcclxuICAgIGhhbmRsZXIgJiYgaGFuZGxlcihldmVudCk7XHJcbiAgfVxyXG59KTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/CTFramework.ts\n'
      );

      /***/
    },

  /***/ "./src/Component.ts":
    /*!**************************!*\
  !*** ./src/Component.ts ***!
  \**************************/
    /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   memo: () => (/* binding */ memo)\n/* harmony export */ });\n/* harmony import */ var _CTFramework__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CTFramework */ "./src/CTFramework.ts");\n\r\n// Component class representing a UI component with state and lifecycle management.\r\nclass Component {\r\n    constructor(props) {\r\n        this.vnode = null;\r\n        this.props = props;\r\n        this.state = {};\r\n    }\r\n    // Set a new state and schedule a re-render if necessary.\r\n    setState(newState) {\r\n        const prevState = this.state;\r\n        this.state = Object.assign(Object.assign({}, this.state), newState);\r\n        // Schedule a re-render asynchronously.\r\n        Promise.resolve().then(() => {\r\n            if (this.vnode && this.shouldComponentUpdate(this.props, prevState)) {\r\n                // Use CTFramework\'s rerender method to update the DOM\r\n                _CTFramework__WEBPACK_IMPORTED_MODULE_0__.CTFramework.rerender(this);\r\n            }\r\n        });\r\n    }\r\n    // Method to control whether a component should re-render.\r\n    // Override this method in individual components if specific checks are needed.\r\n    shouldComponentUpdate(nextProps, nextState) {\r\n        return true; // Default behavior is to always re-render.\r\n    }\r\n    // Render method must be implemented by any class extending Component.\r\n    render() {\r\n        throw new Error(`Render method must be implemented in the component ${this.constructor.name}`);\r\n    }\r\n    // Lifecycle methods, which can be overridden by components.\r\n    componentOnMount() { }\r\n    componentOnUpdate(prevProps, prevState) { }\r\n    componentOnUnmount() { }\r\n    componentOnCatch(error, info) { }\r\n}\r\n// Memoization helper function for components.\r\n// It prevents unnecessary re-renders by checking if the props have changed.\r\nfunction memo(ComponentClass) {\r\n    return class MemoizedComponent extends Component {\r\n        shouldComponentUpdate(nextProps) {\r\n            return shallowCompare(this.props, nextProps); // Use shallow comparison of props to prevent re-rendering.\r\n        }\r\n        // Forward the render method from the original component class\r\n        render() {\r\n            return new ComponentClass(this.props).render();\r\n        }\r\n    };\r\n}\r\n// A shallow comparison function to check if two objects are different.\r\nfunction shallowCompare(obj1, obj2) {\r\n    for (const key in obj1) {\r\n        if (obj1[key] !== obj2[key])\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvQ29tcG9uZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QztBQUc1QyxtRkFBbUY7QUFDNUUsTUFBTSxTQUFTO0lBS3BCLFlBQVksS0FBUTtRQUZwQixVQUFLLEdBQWlCLElBQUksQ0FBQztRQUd6QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsS0FBSyxHQUFHLEVBQU8sQ0FBQztJQUN2QixDQUFDO0lBRUQseURBQXlEO0lBQ3pELFFBQVEsQ0FBQyxRQUFvQjtRQUMzQixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzdCLElBQUksQ0FBQyxLQUFLLG1DQUFRLElBQUksQ0FBQyxLQUFLLEdBQUssUUFBUSxDQUFFLENBQUM7UUFFNUMsdUNBQXVDO1FBQ3ZDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQzFCLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsRUFBRTtnQkFDbkUsc0RBQXNEO2dCQUN0RCxxREFBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM1QjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDBEQUEwRDtJQUMxRCwrRUFBK0U7SUFDL0UscUJBQXFCLENBQUMsU0FBWSxFQUFFLFNBQVk7UUFDOUMsT0FBTyxJQUFJLENBQUMsQ0FBQywyQ0FBMkM7SUFDMUQsQ0FBQztJQUVELHNFQUFzRTtJQUN0RSxNQUFNO1FBQ0osTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ2pHLENBQUM7SUFFRCw0REFBNEQ7SUFDNUQsZ0JBQWdCLEtBQUksQ0FBQztJQUNyQixpQkFBaUIsQ0FBQyxTQUFZLEVBQUUsU0FBWSxJQUFHLENBQUM7SUFDaEQsa0JBQWtCLEtBQUksQ0FBQztJQUN2QixnQkFBZ0IsQ0FBQyxLQUFVLEVBQUUsSUFBUyxJQUFHLENBQUM7Q0FDM0M7QUFFRCw4Q0FBOEM7QUFDOUMsNEVBQTRFO0FBQ3JFLFNBQVMsSUFBSSxDQUFPLGNBQWlEO0lBQzFFLE9BQU8sTUFBTSxpQkFBa0IsU0FBUSxTQUFlO1FBQ3BELHFCQUFxQixDQUFDLFNBQVk7WUFDaEMsT0FBTyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLDJEQUEyRDtRQUMzRyxDQUFDO1FBRUQsOERBQThEO1FBQzlELE1BQU07WUFDSixPQUFPLElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNqRCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCx1RUFBdUU7QUFDdkUsU0FBUyxjQUFjLENBQUMsSUFBUyxFQUFFLElBQVM7SUFDMUMsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDdEIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUFFLE9BQU8sSUFBSSxDQUFDO0tBQzFDO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3RmcmFtZXdvcmsvLi9zcmMvQ29tcG9uZW50LnRzPzRkNmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ1RGcmFtZXdvcmsgfSBmcm9tIFwiLi9DVEZyYW1ld29ya1wiO1xyXG5pbXBvcnQgeyBWTm9kZSB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG4vLyBDb21wb25lbnQgY2xhc3MgcmVwcmVzZW50aW5nIGEgVUkgY29tcG9uZW50IHdpdGggc3RhdGUgYW5kIGxpZmVjeWNsZSBtYW5hZ2VtZW50LlxyXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50PFAgPSB7fSwgUyA9IHt9PiB7XHJcbiAgc3RhdGU6IFM7XHJcbiAgcHJvcHM6IFA7XHJcbiAgdm5vZGU6IFZOb2RlIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQKSB7XHJcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgICB0aGlzLnN0YXRlID0ge30gYXMgUztcclxuICB9XHJcblxyXG4gIC8vIFNldCBhIG5ldyBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIgaWYgbmVjZXNzYXJ5LlxyXG4gIHNldFN0YXRlKG5ld1N0YXRlOiBQYXJ0aWFsPFM+KSB7XHJcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHsgLi4udGhpcy5zdGF0ZSwgLi4ubmV3U3RhdGUgfTtcclxuXHJcbiAgICAvLyBTY2hlZHVsZSBhIHJlLXJlbmRlciBhc3luY2hyb25vdXNseS5cclxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICBpZiAodGhpcy52bm9kZSAmJiB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSh0aGlzLnByb3BzLCBwcmV2U3RhdGUpKSB7XHJcbiAgICAgICAgLy8gVXNlIENURnJhbWV3b3JrJ3MgcmVyZW5kZXIgbWV0aG9kIHRvIHVwZGF0ZSB0aGUgRE9NXHJcbiAgICAgICAgQ1RGcmFtZXdvcmsucmVyZW5kZXIodGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gTWV0aG9kIHRvIGNvbnRyb2wgd2hldGhlciBhIGNvbXBvbmVudCBzaG91bGQgcmUtcmVuZGVyLlxyXG4gIC8vIE92ZXJyaWRlIHRoaXMgbWV0aG9kIGluIGluZGl2aWR1YWwgY29tcG9uZW50cyBpZiBzcGVjaWZpYyBjaGVja3MgYXJlIG5lZWRlZC5cclxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzOiBQLCBuZXh0U3RhdGU6IFMpIHtcclxuICAgIHJldHVybiB0cnVlOyAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGFsd2F5cyByZS1yZW5kZXIuXHJcbiAgfVxyXG5cclxuICAvLyBSZW5kZXIgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYW55IGNsYXNzIGV4dGVuZGluZyBDb21wb25lbnQuXHJcbiAgcmVuZGVyKCk6IFZOb2RlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgUmVuZGVyIG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkIGluIHRoZSBjb21wb25lbnQgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9YCk7XHJcbiAgfVxyXG5cclxuICAvLyBMaWZlY3ljbGUgbWV0aG9kcywgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgY29tcG9uZW50cy5cclxuICBjb21wb25lbnRPbk1vdW50KCkge31cclxuICBjb21wb25lbnRPblVwZGF0ZShwcmV2UHJvcHM6IFAsIHByZXZTdGF0ZTogUykge31cclxuICBjb21wb25lbnRPblVubW91bnQoKSB7fVxyXG4gIGNvbXBvbmVudE9uQ2F0Y2goZXJyb3I6IGFueSwgaW5mbzogYW55KSB7fVxyXG59XHJcblxyXG4vLyBNZW1vaXphdGlvbiBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbXBvbmVudHMuXHJcbi8vIEl0IHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgYnkgY2hlY2tpbmcgaWYgdGhlIHByb3BzIGhhdmUgY2hhbmdlZC5cclxuZXhwb3J0IGZ1bmN0aW9uIG1lbW88UCwgUz4oQ29tcG9uZW50Q2xhc3M6IG5ldyAocHJvcHM6IFApID0+IENvbXBvbmVudDxQLCBTPik6IG5ldyAocHJvcHM6IFApID0+IENvbXBvbmVudDxQLCBTPiB7XHJcbiAgcmV0dXJuIGNsYXNzIE1lbW9pemVkQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50PFAsIFM+IHtcclxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHM6IFApIHtcclxuICAgICAgcmV0dXJuIHNoYWxsb3dDb21wYXJlKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7IC8vIFVzZSBzaGFsbG93IGNvbXBhcmlzb24gb2YgcHJvcHMgdG8gcHJldmVudCByZS1yZW5kZXJpbmcuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yd2FyZCB0aGUgcmVuZGVyIG1ldGhvZCBmcm9tIHRoZSBvcmlnaW5hbCBjb21wb25lbnQgY2xhc3NcclxuICAgIHJlbmRlcigpOiBWTm9kZSB7XHJcbiAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Q2xhc3ModGhpcy5wcm9wcykucmVuZGVyKCk7XHJcbiAgICB9XHJcbiAgfTtcclxufVxyXG5cclxuLy8gQSBzaGFsbG93IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGRpZmZlcmVudC5cclxuZnVuY3Rpb24gc2hhbGxvd0NvbXBhcmUob2JqMTogYW55LCBvYmoyOiBhbnkpOiBib29sZWFuIHtcclxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmoxKSB7XHJcbiAgICBpZiAob2JqMVtrZXldICE9PSBvYmoyW2tleV0pIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Component.ts\n'
      );

      /***/
    },

  /***/ "./src/index.ts":
    /*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
    /***/ (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      eval(
        '__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.Component),\n/* harmony export */   createElement: () => (/* reexport safe */ _CTFramework__WEBPACK_IMPORTED_MODULE_1__.createElement),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   memo: () => (/* reexport safe */ _Component__WEBPACK_IMPORTED_MODULE_0__.memo)\n/* harmony export */ });\n/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./src/Component.ts");\n/* harmony import */ var _CTFramework__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CTFramework */ "./src/CTFramework.ts");\n/// <reference path="./jsx.d.ts" />\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_CTFramework__WEBPACK_IMPORTED_MODULE_1__.CTFramework);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBRVc7QUFDYTtBQUtqQjtBQUMxQyxpRUFBZSxxREFBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3RmcmFtZXdvcmsvLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi9qc3guZC50c1wiIC8+XHJcblxyXG5pbXBvcnQgeyBDb21wb25lbnQsIG1lbW8gfSBmcm9tIFwiLi9Db21wb25lbnRcIjtcclxuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgQ1RGcmFtZXdvcmsgfSBmcm9tIFwiLi9DVEZyYW1ld29ya1wiO1xyXG5pbXBvcnQgeyBWTm9kZSB9IGZyb20gXCIuL3R5cGVzXCI7XHJcblxyXG4vLyBFeHBvcnRpbmcgdHlwZXMgYW5kIGNvbXBvbmVudHNcclxuZXhwb3J0IHR5cGUgeyBWTm9kZSB9O1xyXG5leHBvcnQgeyBDb21wb25lbnQsIG1lbW8sIGNyZWF0ZUVsZW1lbnQgfTtcclxuZXhwb3J0IGRlZmF1bHQgQ1RGcmFtZXdvcms7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n'
      );

      /***/
    },

  /******/
};
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
  /******/ // Check if module is in cache
  /******/ var cachedModule = __webpack_module_cache__[moduleId];
  /******/ if (cachedModule !== undefined) {
    /******/ return cachedModule.exports;
    /******/
  }
  /******/ // Create a new module (and put it into the cache)
  /******/ var module = (__webpack_module_cache__[moduleId] = {
    /******/ // no module.id needed
    /******/ // no module.loaded needed
    /******/ exports: {},
    /******/
  });
  /******/
  /******/ // Execute the module function
  /******/ __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
  /******/
  /******/ // Return the exports of the module
  /******/ return module.exports;
  /******/
}
/******/
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
  /******/ // define getter functions for harmony exports
  /******/ __webpack_require__.d = (exports, definition) => {
    /******/ for (var key in definition) {
      /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        /******/
      }
      /******/
    }
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
  /******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  /******/
})();
/******/
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
  /******/ // define __esModule on exports
  /******/ __webpack_require__.r = (exports) => {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  };
  /******/
})();
/******/
/************************************************************************/
/******/
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval-source-map devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ var __webpack_exports__Component = __webpack_exports__.Component;
/******/ var __webpack_exports__createElement = __webpack_exports__.createElement;
/******/ var __webpack_exports__default = __webpack_exports__["default"];
/******/ var __webpack_exports__memo = __webpack_exports__.memo;
/******/ export { __webpack_exports__Component as Component, __webpack_exports__createElement as createElement, __webpack_exports__default as default, __webpack_exports__memo as memo };
/******/
