{
  "version": 3,
  "file": "index.min.js",
  "mappings": "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",
  "sources": [
    "webpack://CTFramework/webpack/universalModuleDefinition",
    "webpack://CTFramework/./src/CTFramework.ts"
  ],
  "sourcesContent": [
    "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CTFramework\"] = factory();\n\telse\n\t\troot[\"CTFramework\"] = factory();\n})(this, () => {\nreturn ",
    "export function createElement(tag, props, ...children) {\n    props = props || {};\n        return {\n        tag,\n        props: Object.assign({}, props),\n        children: children.flat(),\n        key: (props === null || props === void 0 ? void 0 : props.key) || null,\n    };\n}\nexport function Fragment(props) {\n    return props.children || [];\n}\nexport class CTFramework {\n    // Render a component into a DOM container.\n    static render(component, container) {\n        const vnode = component.render(); // Generate the initial virtual node from the component's render method.\n        vnode.component = component;\n        component.vnode = vnode;\n        const dom = CTFramework.createDom(vnode); // Create the actual DOM element from the virtual node.\n        container.appendChild(dom); // Attach it to the container.\n        CTFramework.onMount(vnode); // Trigger the component's mount lifecycle.\n    }\n    // Schedule updates to be processed in the next animation frame for better performance.\n    static scheduleUpdate(updateFn) {\n        CTFramework.pendingUpdates.push(updateFn);\n        if (CTFramework.pendingUpdates.length === 1) {\n            requestAnimationFrame(CTFramework.processUpdates);\n        }\n    }\n    // Process all pending updates from the queue.\n    static processUpdates() {\n        while (CTFramework.pendingUpdates.length) {\n            const updateFn = CTFramework.pendingUpdates.shift();\n            updateFn && updateFn();\n        }\n    }\n    // Re-render a component and update the DOM only if necessary.\n    static rerender(component) {\n        var _a, _b;\n        if (!component.vnode)\n            return;\n        const oldVNode = component.vnode;\n        if (!component.shouldComponentUpdate(component.props, component.state)) {\n            return; // Skip re-render if shouldComponentUpdate returns false.\n        }\n        const newVNode = component.render(); // Render the updated virtual node.\n        newVNode.component = component;\n        const updatedDom = CTFramework.updateDom(oldVNode, newVNode); // Update the DOM.\n        // Replace the DOM node if necessary.\n        if (typeof oldVNode !== \"string\" && updatedDom !== oldVNode.dom && oldVNode.dom) {\n            (_b = (_a = oldVNode.dom) === null || _a === void 0 ? void 0 : _a.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(updatedDom, oldVNode.dom);\n        }\n        component.vnode = newVNode; // Store the new virtual node in the component.\n        component.componentOnUpdate(component.props, component.state); // Trigger the update lifecycle.\n    }\n    // Create a DOM node from a virtual node.\n    static createDom(vnode) {\n        if (typeof vnode === \"string\" || typeof vnode === \"number\") {\n            return document.createTextNode(String(vnode)); // Convert numbers to text nodes as well.\n        }\n        if (typeof vnode.tag === \"function\") {\n            // Handle functional or class-based components.\n            const ComponentClass = vnode.tag;\n            const component = new ComponentClass(vnode.props);\n            const componentVNode = component.render();\n            componentVNode.component = component;\n            vnode.component = component;\n            component.vnode = componentVNode;\n            const dom = CTFramework.createDom(componentVNode);\n            vnode.dom = dom;\n            component.componentOnMount();\n            return dom;\n        }\n        const element = document.createElement(vnode.tag); // Create a DOM element for the tag.\n        vnode.dom = element;\n        // Event delegation: Attach a data-event-id attribute and store the event handler.\n        element.setAttribute(\"data-event-id\", `${Math.random()}`);\n        CTFramework.eventHandlers[element.getAttribute(\"data-event-id\")] = vnode.props.onClick;\n        // Set properties and styles.\n        CTFramework.updateDomProperties(element, {}, vnode.props);\n        // Recursively create DOM for child nodes.\n        vnode.children.forEach((child) => {\n            const childDom = CTFramework.createDom(child);\n            element.appendChild(childDom);\n        });\n        return element;\n    }\n    // Update the DOM by comparing the old and new virtual nodes.\n    static updateDom(oldVNode, newVNode) {\n        // Handle text nodes\n        if (typeof oldVNode === \"string\" || typeof newVNode === \"string\") {\n            const newTextContent = (typeof newVNode === \"string\" ? newVNode : \"\") || \"\";\n            if (oldVNode !== newTextContent) {\n                return document.createTextNode(newTextContent);\n            }\n            return typeof oldVNode === \"string\" ? document.createTextNode(oldVNode) : oldVNode.dom;\n        }\n        // Static node check remains\n        if (oldVNode.isStatic) {\n            newVNode.dom = oldVNode.dom;\n            newVNode.component = oldVNode.component;\n            return newVNode.dom;\n        }\n        // Replace node if tag is different\n        if (oldVNode.tag !== newVNode.tag) {\n            const newDom = CTFramework.createDom(newVNode);\n            if (oldVNode.dom && oldVNode.dom.parentNode) {\n                oldVNode.dom.parentNode.replaceChild(newDom, oldVNode.dom);\n            }\n            return newDom;\n        }\n        const dom = oldVNode.dom;\n        newVNode.dom = dom;\n        // **Ensure text content is updated**:\n        // If we're dealing with text inside an element (like <h1>)\n        if (newVNode.children.length === 1 && typeof newVNode.children[0] === \"string\") {\n            if (dom.textContent !== newVNode.children[0]) {\n                dom.textContent = newVNode.children[0]; // Update text directly\n            }\n        }\n        // Update properties even if children haven't changed\n        CTFramework.updateDomProperties(dom, oldVNode.props, newVNode.props);\n        // Handle children updates (only if they exist)\n        const oldChildren = oldVNode.children || [];\n        const newChildren = newVNode.children || [];\n        if (oldChildren.length === 0 && newChildren.length === 0) {\n            return CTFramework.createDom(newVNode);\n        }\n        const oldChildrenMap = new Map();\n        // Map old children by keys if any\n        oldChildren.forEach((child) => {\n            if (child && typeof child !== \"string\" && child.key) {\n                oldChildrenMap.set(child.key, child); // **Track children by key**\n            }\n        });\n        // **Iterate through new children**\n        newChildren.forEach((newChild, i) => {\n            if (typeof newChild === \"string\") {\n                const newTextContent = newChild || \"\";\n                const oldChild = oldChildren[i];\n                if (typeof oldChild === \"string\" && oldChild !== newTextContent) {\n                    // **Update text content if needed**\n                    dom.childNodes[i].textContent = newTextContent;\n                }\n                else if (dom.childNodes[i]) {\n                    dom.replaceChild(document.createTextNode(newTextContent), dom.childNodes[i]);\n                }\n                else {\n                    dom.appendChild(document.createTextNode(newTextContent));\n                }\n            }\n            else {\n                const key = newChild.key;\n                const oldChild = key ? oldChildrenMap.get(key) : oldChildren[i]; // **Look for matching old child by key or index**\n                if (oldChild) {\n                    // **Update the DOM for the matching child**\n                    const updatedChildDom = CTFramework.updateDom(oldChild, newChild);\n                    if (dom.childNodes[i] !== updatedChildDom) {\n                        dom.replaceChild(updatedChildDom, dom.childNodes[i]);\n                    }\n                    if (key)\n                        oldChildrenMap.delete(key); // **Remove key from map once updated**\n                }\n                else {\n                    // **If no matching old child, create a new DOM node**\n                    const newChildDom = CTFramework.createDom(newChild);\n                    dom.appendChild(newChildDom);\n                }\n            }\n        });\n        // **Remove old children that are no longer present**\n        oldChildrenMap.forEach((oldChild) => {\n            if (oldChild.dom && dom.contains(oldChild.dom)) {\n                dom.removeChild(oldChild.dom); // **Remove old DOM elements that are no longer in newVNode**\n            }\n        });\n        return dom;\n    }\n    // Update the properties and styles of a DOM element.\n    static updateDomProperties(dom, oldProps, newProps) {\n        const changes = CTFramework.getPropChanges(oldProps, newProps);\n        changes.forEach(({ name, value }) => {\n            if (name === \"style\") {\n                CTFramework.updateStyle(dom, oldProps.style, newProps.style);\n            }\n            else if (name.startsWith(\"on\")) {\n                // Update event listeners\n                const eventType = name.toLowerCase().substring(2);\n                dom.removeEventListener(eventType, oldProps[name]);\n                dom.addEventListener(eventType, value);\n            }\n            else if (name === \"textContent\") {\n                dom.textContent = value;\n            }\n            else if (name in dom) {\n                // Update direct properties if they exist in the DOM element, e.g. 'textContent' or 'value'\n                dom[name] = value;\n            }\n            else {\n                // Fallback to setting it as an attribute if it's not a direct DOM property\n                dom.setAttribute(name, value);\n            }\n        });\n    }\n    // Get the differences between the old and new props for efficient updates.\n    static getPropChanges(oldProps, newProps) {\n        const changes = [];\n        for (const name in newProps) {\n            if (newProps[name] !== oldProps[name]) {\n                changes.push({ name, value: newProps[name] });\n            }\n        }\n        return changes;\n    }\n    // Add the missing updateStyle function.\n    static updateStyle(dom, oldStyle = {}, newStyle = {}) {\n        // If styles are provided as a string, update the style attribute.\n        if (typeof oldStyle === \"string\" || typeof newStyle === \"string\") {\n            dom.setAttribute(\"style\", newStyle || \"\");\n        }\n        else {\n            // Remove old styles not present in the new styles.\n            Object.keys(oldStyle).forEach((key) => {\n                if (!(key in newStyle)) {\n                    dom.style[key] = \"\";\n                }\n            });\n            // Apply new styles.\n            Object.keys(newStyle).forEach((key) => {\n                if (oldStyle[key] !== newStyle[key]) {\n                    dom.style[key] = newStyle[key];\n                }\n            });\n        }\n    }\n    // Helper method to handle the component mount lifecycle.\n    static onMount(vnode) {\n        if (typeof vnode === \"string\")\n            return;\n        if (vnode.component) {\n            vnode.component.componentOnMount(); // Trigger component mount lifecycle.\n        }\n        vnode.children.forEach((child) => CTFramework.onMount(child));\n    }\n    // Helper method to handle the component unmount lifecycle.\n    static onUnmount(vnode) {\n        if (typeof vnode === \"string\")\n            return;\n        if (vnode.component) {\n            vnode.component.componentOnUnmount(); // Trigger component unmount lifecycle.\n        }\n        vnode.children.forEach((child) => CTFramework.onUnmount(child));\n    }\n}\nCTFramework.eventHandlers = {}; // Store event handlers by their unique event ID.\nCTFramework.pendingUpdates = []; // Queue for pending updates to be processed.\n// Event delegation: A single event listener handles all click events.\ndocument.addEventListener(\"click\", (event) => {\n    let target = event.target;\n    while (target && !target.hasAttribute(\"data-event-id\")) {\n        target = target.parentElement;\n    }\n    if (target) {\n        const handler = CTFramework.eventHandlers[target.getAttribute(\"data-event-id\")];\n        handler && handler(event);\n    }\n});\n"
  ],
  "names": [
    "root",
    "factory",
    "exports",
    "module",
    "define",
    "amd",
    "this",
    "render",
    "component",
    "container",
    "vnode",
    "dom",
    "createDom",
    "appendChild",
    "onMount",
    "scheduleUpdate",
    "updateFn",
    "pendingUpdates",
    "push",
    "length",
    "requestAnimationFrame",
    "processUpdates",
    "shift",
    "rerender",
    "_a",
    "_b",
    "oldVNode",
    "shouldComponentUpdate",
    "props",
    "state",
    "newVNode",
    "updatedDom",
    "updateDom",
    "parentNode",
    "replaceChild",
    "componentOnUpdate",
    "document",
    "createTextNode",
    "String",
    "tag",
    "ComponentClass",
    "componentVNode",
    "componentOnMount",
    "element",
    "createElement",
    "setAttribute",
    "Math",
    "random",
    "eventHandlers",
    "getAttribute",
    "onClick",
    "updateDomProperties",
    "children",
    "forEach",
    "child",
    "childDom",
    "newTextContent",
    "isStatic",
    "newDom",
    "textContent",
    "oldChildren",
    "newChildren",
    "oldChildrenMap",
    "Map",
    "key",
    "set",
    "newChild",
    "i",
    "oldChild",
    "childNodes",
    "get",
    "updatedChildDom",
    "delete",
    "newChildDom",
    "contains",
    "removeChild",
    "oldProps",
    "newProps",
    "getPropChanges",
    "name",
    "value",
    "updateStyle",
    "style",
    "startsWith",
    "eventType",
    "toLowerCase",
    "substring",
    "removeEventListener",
    "addEventListener",
    "changes",
    "oldStyle",
    "newStyle",
    "Object",
    "keys",
    "onUnmount",
    "componentOnUnmount",
    "event",
    "target",
    "hasAttribute",
    "parentElement",
    "handler"
  ],
  "sourceRoot": ""
}
